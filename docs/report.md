# ДОКЛАД

## Тема: «Разработка Telegram-бота с веб-интерфейсом для интерактивной доски вопросов и ответов (Live Q&A Wall)»

---

### 1. Введение

Настоящий доклад посвящён описанию учебного проекта **«Live Q&A Wall»** — серверного приложения, реализующего Telegram-бота, интегрированного с веб-интерфейсом для публичного отображения пользовательских сообщений в режиме реального времени.

**Цель проекта** — разработка полнофункционального клиент-серверного приложения, демонстрирующего практические навыки работы с Telegram Bot API, микро-веб-фреймворком Flask, реляционной базой данных SQLite, а также принципами построения REST API и развёртывания веб-приложений на облачной платформе.

**Задачи проекта:**

1. Реализовать Telegram-бота, принимающего текстовые, фото- и видеосообщения от пользователей.
2. Обеспечить сохранение входящих данных в реляционную базу данных.
3. Разработать веб-страницу, отображающую поступившие сообщения в режиме, приближённом к реальному времени.
4. Развернуть приложение на внешнем хостинге (PythonAnywhere) с использованием webhook-механизма.

---

### 2. Описание технологического стека

#### 2.1. Язык программирования — Python 3

**Обоснование выбора.** Python является одним из наиболее распространённых языков программирования общего назначения, рекомендуемых для учебных и прикладных проектов. Ключевые аргументы в пользу выбора данного языка:

- **Читаемость и лаконичность синтаксиса.** Python обеспечивает высокую скорость разработки благодаря минимальному количеству вспомогательного кода (boilerplate). Это позволяет сосредоточиться на бизнес-логике приложения.
- **Обширная экосистема библиотек.** Стандартная библиотека Python включает модули для работы с базами данных (`sqlite3`), HTTP-запросами, работы с датой и временем (`datetime`), операционной системой (`os`, `sys`), что устраняет необходимость установки дополнительных зависимостей для базовых операций.
- **Совместимость с платформой PythonAnywhere.** Выбранная хостинг-платформа ориентирована на Python-приложения и обеспечивает бесшовное развёртывание Flask-проектов через WSGI-интерфейс.
- **Широкая поддержка сообществом.** Наличие подробной документации и большого числа руководств на русском языке существенно снижает порог входа при выполнении учебных задач.

---

#### 2.2. Веб-фреймворк — Flask 3.0.0

**Обоснование выбора.** Flask — микро-фреймворк для создания веб-приложений на Python, придерживающийся философии минимализма и модульности.

**Причины выбора Flask вместо альтернатив (Django, FastAPI):**

| Критерий | Flask | Django | FastAPI |
|---|---|---|---|
| Минимализм | Микрофреймворк, не навязывает архитектуру | Полный стек (ORM, админ-панель, аутентификация) | Ориентирован на асинхронные API |
| Порог входа | Низкий | Высокий | Средний |
| Размер проекта | Идеален для малых и средних приложений | Оправдан для крупных проектов | Специализирован под API-first |
| Шаблонизация | Встроенный Jinja2 | Собственный движок | Отсутствует |
| Развёртывание | WSGI (совместим с PythonAnywhere) | WSGI | ASGI (требует Uvicorn) |

Flask был выбран по следующим основаниям:

1. **Масштаб проекта не требует полного стека.** Django предоставляет встроенный ORM, систему администрирования и механизм миграций — все эти компоненты являются избыточными для проекта уровня одной таблицы в SQLite.
2. **Явный контроль над маршрутами.** Flask использует декоратор `@app.route()` для определения маршрутов, что делает структуру HTTP-эндпоинтов прозрачной и легко читаемой.
3. **Совместимость с PythonAnywhere.** Платформа PythonAnywhere нативно поддерживает WSGI-приложения; Flask-приложение развёртывается путём указания переменной `app` в модуле — без дополнительной конфигурации.
4. **Встроенная поддержка шаблонов.** Функция `render_template()` позволяет возвращать HTML-страницы, сгенерированные из Jinja2-шаблонов, что покрывает потребность проекта в единственной веб-странице.

**Используемые возможности Flask в проекте:**

- `Flask(__name__)` — создание экземпляра приложения.
- `@app.route('/')` — маршрут главной страницы, возвращающий HTML-шаблон.
- `@app.route('/api/messages')` — REST-эндпоинт, возвращающий JSON-массив сообщений.
- `@app.route('/api/media/<int:msg_id>')` — эндпоинт для отдачи бинарных данных (фотографий и видеозаписей) по идентификатору сообщения.
- `@app.route('/webhook', methods=['POST'])` — эндпоинт для приёма входящих обновлений от Telegram через webhook.
- `jsonify()` — сериализация Python-объектов в JSON-ответ.
- `Response()` — формирование HTTP-ответа с произвольным MIME-типом для отдачи медиа-файлов.

---

#### 2.3. Библиотека Telegram Bot API — pyTelegramBotAPI 4.14.0

**Обоснование выбора.** pyTelegramBotAPI (импортируется как `telebot`) — высокоуровневая Python-обёртка над Telegram Bot API, предоставляющая декларативный интерфейс для обработки сообщений.

**Причины выбора pyTelegramBotAPI вместо альтернатив (python-telegram-bot, aiogram):**

| Критерий | pyTelegramBotAPI | python-telegram-bot | aiogram |
|---|---|---|---|
| Парадигма | Синхронная (с опциональным threading) | Асинхронная (v20+) | Асинхронная |
| Сложность API | Простой декораторный стиль | Более сложная архитектура обработчиков | Middleware-ориентированная |
| Интеграция с Flask | Бесшовная (синхронный режим) | Требует адаптера для синхронных фреймворков | Несовместим с WSGI |
| Документация | Обширная, множество примеров | Полная, но более объёмная | Ориентирована на продвинутых разработчиков |
| Параметр `threaded=False` | Поддерживается | Неприменим | Неприменим |

Ключевые преимущества для данного проекта:

1. **Синхронная работа с Flask.** Параметр `threaded=False` при инициализации бота устраняет проблемы с многопоточностью в среде PythonAnywhere, где WSGI-процесс обрабатывает запросы последовательно.
2. **Минимальный объём кода.** Декоратор `@bot.message_handler()` позволяет определять обработчики сообщений в одну строку, с фильтрацией по типу контента (`content_types=['text', 'photo', 'video']`) или по условию (`func=lambda m: m.text == "..."` ).
3. **Встроенная десериализация.** Метод `telebot.types.Update.de_json()` автоматически преобразует JSON-строку из webhook-запроса в объект `Update`, что избавляет от ручного парсинга.
4. **Двойной режим работы.** Библиотека поддерживает как webhook-режим (для продакшен-развёртывания), так и polling-режим (`bot.infinity_polling()`) для локальной отладки.

**Используемые возможности библиотеки в проекте:**

- `telebot.TeleBot(token, threaded=False)` — создание экземпляра бота в синхронном режиме.
- `@bot.message_handler(commands=['start'])` — обработка команды `/start`.
- `@bot.message_handler(content_types=['text', 'photo', 'video'])` — обработка входящих сообщений разных типов.
- `telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)` — создание пользовательской клавиатуры с кнопками «Написать вопрос» и «Анонимный режим».
- `bot.get_user_profile_photos()` — получение аватара пользователя для отображения на веб-странице.
- `bot.get_file()` и `bot.download_file()` — скачивание медиа-файлов (фотографий и видеозаписей), прикреплённых к сообщению.
- `bot.set_webhook()` / `bot.remove_webhook()` — управление webhook-адресом.

---

#### 2.4. База данных — SQLite3

**Обоснование выбора.** SQLite — встраиваемая реляционная СУБД, не требующая отдельного сервера и хранящая всю базу данных в единственном файле.

**Причины выбора SQLite вместо альтернатив (PostgreSQL, MySQL, MongoDB):**

1. **Отсутствие необходимости в отдельном сервере СУБД.** SQLite работает внутри процесса приложения; это устраняет задачи администрирования, настройки подключений и управления пользователями БД.
2. **Вхождение в стандартную библиотеку Python.** Модуль `sqlite3` доступен «из коробки» — не требуется установка дополнительных пакетов.
3. **Совместимость с PythonAnywhere.** Бесплатный тариф PythonAnywhere не предоставляет доступ к PostgreSQL, однако позволяет использовать файловую SQLite-базу без ограничений.
4. **Достаточная производительность.** Для учебного проекта с ожидаемой нагрузкой в десятки-сотни записей SQLite обеспечивает избыточный запас производительности.

**Особенности реализации модуля `database.py`:**

- **Динамическое определение пути к файлу БД.** Модуль автоматически определяет, выполняется ли код на сервере PythonAnywhere (по наличию директории `/home/arikatte`) или на локальной машине, и выбирает соответствующий путь к файлу `messages.db`. Это обеспечивает переносимость кода между окружениями без изменения конфигурации.
- **Принудительное создание таблицы при каждом подключении.** Инструкция `CREATE TABLE IF NOT EXISTS` в функции `get_connection()` гарантирует, что таблица `messages` будет создана даже в случае, если файл базы данных был удалён или повреждён. Это решение повышает отказоустойчивость приложения.
- **Использование `sqlite3.Row` в качестве `row_factory`.** Данная настройка позволяет обращаться к столбцам результата запроса по именам (а не по индексам), что упрощает сериализацию данных в JSON через `dict(row)`.
- **Хранение медиа-файлов в виде BLOB.** Фотографии и видеозаписи хранятся непосредственно в базе данных в бинарном формате. Это упрощает архитектуру, устраняя необходимость в отдельном файловом хранилище и логике управления путями.
- **Раздельная выборка метаданных и медиа.** Функция `get_latest_messages()` намеренно исключает столбец `media_blob` из SELECT-запроса, возвращая только метаинформацию. Бинарные данные загружаются по отдельному запросу через функцию `get_media()`. Это снижает объём передаваемых данных при формировании ленты сообщений.

**Схема таблицы `messages`:**

| Столбец | Тип | Описание |
|---|---|---|
| `id` | `INTEGER PRIMARY KEY AUTOINCREMENT` | Уникальный идентификатор сообщения |
| `user_id` | `INTEGER` | Telegram-идентификатор пользователя |
| `user_name` | `TEXT` | Отображаемое имя (или «Аноним») |
| `photo_url` | `TEXT` | URL аватара пользователя (или NULL в анонимном режиме) |
| `text` | `TEXT` | Текст сообщения или подпись к медиа |
| `timestamp` | `TEXT` | Время публикации в формате `YYYY-MM-DD HH:MM:SS` |
| `media_type` | `TEXT` | Тип медиа: `photo`, `video` или `NULL` |
| `media_blob` | `BLOB` | Бинарные данные медиа-файла |

---

#### 2.5. Библиотека python-dotenv 1.0.0

**Обоснование выбора.** python-dotenv загружает переменные окружения из файла `.env` в `os.environ`, обеспечивая разделение конфигурации и кода.

**Назначение в проекте.** Файл `.env` содержит секретные данные — токен бота (`BOT_TOKEN`) и адрес доски (`BOARD_URL`). Библиотека используется в утилитарном скрипте `set_webhook.py`:

```python
from dotenv import load_dotenv
load_dotenv()
BOT_TOKEN = os.environ.get('BOT_TOKEN')
```

**Преимущества подхода:**

1. **Безопасность.** Файл `.env` добавлен в `.gitignore`, что исключает попадание токена бота в систему контроля версий.
2. **Гибкость.** Переменные окружения можно задавать как через `.env`-файл (при локальной разработке), так и через панель управления хостинга (PythonAnywhere → Web → Environment variables).
3. **Стандартизация.** Паттерн «12-Factor App» рекомендует хранить конфигурацию в переменных окружения; python-dotenv является де-факто стандартом реализации этого принципа в Python-проектах.

---

### 3. Архитектура приложения

#### 3.1. Общая схема взаимодействия компонентов

```
┌─────────────┐     HTTPS (webhook)      ┌──────────────────────┐
│  Telegram   │ ───────────────────────►  │    Flask (app.py)    │
│  серверы    │                           │                      │
└─────────────┘                           │  ┌──── /webhook ───┐ │
                                          │  │ bot.process()   │ │
┌─────────────┐     GET /api/messages     │  │                 │ │
│  Браузер    │ ◄────────────────────────  │  ├── /api/messages │ │
│  (клиент)   │     (JSON)                │  │                 │ │
│             │ ◄────────────────────────  │  ├── /api/media/id │ │
│             │     (BLOB)                │  │                 │ │
└─────────────┘                           │  └─────────────────┘ │
                                          │         │            │
                                          │         ▼            │
                                          │  ┌─────────────┐    │
                                          │  │ database.py  │    │
                                          │  │  (SQLite3)   │    │
                                          │  └─────────────┘    │
                                          └──────────────────────┘
```

#### 3.2. Механизм Webhook

Telegram Bot API предоставляет два способа получения обновлений:

1. **Long Polling** — бот периодически опрашивает серверы Telegram, запрашивая новые сообщения. Используется при локальной разработке (`bot.infinity_polling()`).
2. **Webhook** — серверы Telegram самостоятельно отправляют POST-запросы на указанный URL при поступлении нового сообщения. Используется в продакшен-среде.

В проекте реализованы оба режима. При запуске файла `app.py` напрямую (`__name__ == '__main__'`) активируется polling для удобства отладки. На PythonAnywhere приложение запускается через WSGI, и маршрут `/webhook` принимает входящие POST-запросы от Telegram.

Утилитарный скрипт `set_webhook.py` обеспечивает управление webhook-адресом из командной строки:

```
python3 set_webhook.py https://arikatte.pythonanywhere.com
python3 set_webhook.py delete
```

---

#### 3.3. Механизм анонимности

Реализована возможность отправки сообщений в анонимном режиме. Состояние анонимности хранится в оперативной памяти сервера в виде множества `anon_users` (тип `set`), содержащего Telegram-идентификаторы пользователей, активировавших анонимный режим.

При нажатии кнопки «Анонимный режим» в клавиатуре бота:

- Если пользователь уже в анонимном режиме — он деактивируется (ID удаляется из множества).
- Если пользователь не в анонимном режиме — он активируется (ID добавляется в множество).

В анонимном режиме имя пользователя заменяется на «Аноним», а аватар не передаётся на веб-страницу.

**Ограничение подхода:** поскольку состояние хранится в памяти процесса, при перезапуске (Reload) сервера множество `anon_users` обнуляется. Для учебного проекта данное ограничение является приемлемым.

---

#### 3.4. REST API

Серверная часть предоставляет три HTTP-эндпоинта:

| Метод | Маршрут | Описание |
|---|---|---|
| `GET` | `/` | Возвращает HTML-страницу (шаблон `index.html`) |
| `GET` | `/api/messages` | Возвращает JSON-массив последних 50 сообщений (без бинарных данных) |
| `GET` | `/api/media/<id>` | Возвращает бинарные данные медиа-файла с соответствующим MIME-типом |

Такое разделение соответствует принципу **ленивой загрузки (lazy loading):** медиа-контент загружается браузером только при необходимости — при отображении конкретной карточки сообщения.

---

### 4. Клиентская часть (фронтенд)

#### 4.1. Архитектурные решения

Фронтенд реализован в виде **одностраничного HTML-документа** (`templates/index.html`) без использования сторонних JavaScript-библиотек или фреймворков (React, Vue и т.д.). Данный подход обусловлен:

1. **Минимизацией зависимостей.** Отсутствие сборочных инструментов (webpack, Vite) упрощает развёртывание.
2. **Соразмерностью задаче.** Для отображения ленты сообщений с периодическим обновлением достаточно нативных возможностей JavaScript.

#### 4.2. Механизм обновления в реальном времени

Фронтенд реализует **механизм опроса (polling):** каждые 3 секунды выполняется HTTP-запрос `GET /api/messages` через `fetch()` API.

```javascript
async function poll() {
    const res = await fetch('/api/messages');
    const data = await res.json();
    data.reverse().forEach(m => {
        if (!seen.has(m.id)) {
            seen.add(m.id);
            feed.insertAdjacentElement('afterbegin', buildCard(m, fresh));
        }
    });
}
setInterval(poll, 3000);
```

**Оптимизация отображения:**

- Множество `seen` (тип `Set`) хранит идентификаторы уже отрисованных сообщений, предотвращая дублирование DOM-элементов.
- Новые сообщения добавляются в начало ленты (`insertAdjacentElement('afterbegin')`), обеспечивая обратный хронологический порядок.
- Анимация `rise` (CSS `@keyframes`) применяется только к вновь появившимся карточкам, создавая визуальный эффект «всплытия».

#### 4.3. Дизайн и типографика

- Используется шрифт **Inter** (Google Fonts) — гротескный шрифт, оптимизированный для экранного отображения.
- Цветовая палитра аватаров (массив `COLORS`) обеспечивает визуальное различение пользователей. Цвет определяется детерминированно на основе `user_id`, что гарантирует постоянство цвета для каждого пользователя.
- Карточки сообщений стилизованы с использованием `box-shadow` и `border-radius: 16px`, создавая материальную визуальную иерархию.

#### 4.4. Защита от XSS

Функция `esc()` экранирует символы `&`, `<`, `>` в пользовательском вводе перед вставкой в DOM через `innerHTML`, предотвращая инъекцию вредоносного HTML/JavaScript-кода.

---

### 5. Развёртывание на PythonAnywhere

Проект развёрнут на облачной платформе **PythonAnywhere** (https://www.pythonanywhere.com) на бесплатном тарифе «Beginner».

**Причины выбора PythonAnywhere:**

1. **Бесплатный тариф** с поддержкой WSGI-приложений и доменом `*.pythonanywhere.com`.
2. **Нативная поддержка Flask** — развёртывание требует минимальной конфигурации (указание пути к `app` в WSGI-файле).
3. **Встроенный HTTPS-сертификат**, необходимый для работы Telegram-webhook (Telegram отправляет обновления только на HTTPS-адреса).
4. **Веб-консоль и файловый менеджер**, упрощающие управление проектом без настройки SSH.

**Процедура развёртывания:**

1. Загрузка файлов проекта через веб-консоль PythonAnywhere.
2. Настройка виртуального окружения и установка зависимостей из `requirements.txt`.
3. Конфигурация WSGI-файла: указание пути к `app` из модуля `app.py`.
4. Установка webhook-адреса командой: `python3 set_webhook.py https://arikatte.pythonanywhere.com`.

---

### 6. Структура проекта

```
project/
├── app.py              # Главный модуль: Flask-приложение + обработчики бота
├── database.py         # Модуль работы с базой данных SQLite
├── set_webhook.py      # Утилита для управления webhook-адресом
├── requirements.txt    # Зависимости проекта
├── .env                # Конфигурация (токен, URL) — не включён в Git
├── .gitignore          # Правила исключения файлов из Git
├── messages.db         # Файл базы данных SQLite (генерируется автоматически)
├── templates/
│   └── index.html      # Шаблон веб-страницы (фронтенд)
└── docs/
    └── report.md       # Настоящий доклад
```

---

### 7. Заключение

В ходе выполнения практической работы был разработан полнофункциональный проект, включающий:

- Telegram-бота с поддержкой текстовых, фото- и видеосообщений, а также режимом анонимной публикации.
- Серверное Flask-приложение с REST API для обмена данными между ботом, базой данных и фронтендом.
- Клиентскую веб-страницу с автоматическим обновлением ленты сообщений.
- Развёртывание на облачной платформе PythonAnywhere с использованием webhook-протокола.

Выбор технологического стека обусловлен принципами минимальной достаточности, совместимости компонентов и соответствия требованиям хостинг-платформы. Каждая используемая библиотека выполняет чётко определённую роль и не является избыточной для масштаба проекта.

---

### Список использованных источников

1. Telegram Bot API — официальная документация: https://core.telegram.org/bots/api
2. Flask — официальная документация: https://flask.palletsprojects.com/
3. pyTelegramBotAPI — документация и примеры: https://github.com/eternnoir/pyTelegramBotAPI
4. SQLite — официальная документация: https://www.sqlite.org/docs.html
5. python-dotenv — документация: https://pypi.org/project/python-dotenv/
6. PythonAnywhere — руководство по развёртыванию Flask: https://help.pythonanywhere.com/pages/Flask/
7. The Twelve-Factor App — принципы конфигурации: https://12factor.net/config
